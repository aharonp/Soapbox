/*
 * routing-stream.js: A Stream focused on connecting an arbitrary RequestStream and
 * ResponseStream through a given Router.
 *
 * (C) 2011, Nodejitsu Inc.
 * MIT LICENSE
 *
 */
 
var util = require('util'),
    union = require('./index'),
    RequestStream = require('./request-stream'),
    ResponseStream = require('./response-stream');

//
// ### function RequestStream (options) 
// 
//  
var RoutingStream = module.exports = function (options) {
  options = options || {};
  RequestStream.call(this, options);
  
  this.before = options.before || [];
  this.after = options.after || [];
  this.response = options.response || options.res;
  this.headers = options.headers || {
    'x-powered-by': 'union ' + union.version
  };

  this.target = new ResponseStream({
    response: this.response,
    headers: this.headers
  });

  this.once('pipe', this.route);
};

util.inherits(RoutingStream, RequestStream);

//
// Called when this instance is piped to **by another stream**
//
RoutingStream.prototype.route = function (req) {

  //
  // When a `RoutingStream` is piped to:
  //
  // 1. Setup the pipe-chain between the `after` middleware, the abstract response
  //    and the concrete response. 
  // 2. Attempt to dispatch to the `before` middleware, which represent things such as 
  //    favicon, static files, application routing. 
  // 3. If no match is found then pipe to the 404Stream
  //
  var self = this,
      after,
      error,
      i;

  // make sure data from req is piped on the `once` first call
  req.on('data', function () { 
    self.emit.apply(self, ["data"].concat([].slice.call(arguments,0))); 
  });

  //
  // Don't allow `this.target` to be writable on HEAD requests
  //
  this.target.writable = req.method !== 'HEAD';

  //
  // 1. Setup the pipe-chain between the `after` middleware, the abstract response
  //    and the concrete response. 
  //
  after = [this.target].concat(this.after, this.response);
  for (i = 0; i < after.length - 1; i++) {
    // attach req to all streams
    after[i].req = req;
    after[i+1].req = req;
    after[i].res = this.response;
    after[i+1].res = this.response;
    after[i].pipe(after[i + 1]);
    // prevent multiple responses and memory leaks
    after[i].on('error', this.onError);
  }
  
  //
  // Helper function for dispatching to the 404 stream.
  //
  function notFound() {
    error = new Error('Not found');
    error.status = 404;
    self.onError(error);
  }
  
  //
  // 2. Attempt to dispatch to the `before` middleware, which represent things such as 
  //    favicon, static files, application routing. 
  //
  (function dispatch(i) {
    if (self.target.modified) {
      return;
    }
    else if (++i === self.before.length) {
      //
      // 3. If no match is found then pipe to the 404Stream
      //
      return notFound();
    }

    self.target.once('next', dispatch.bind(null, i));
    if (self.before[i].length === 3) {
      self.before[i](self, self.target, function (err) {
        if (err) {
          self.onError(err);
        } else {
          self.target.emit('next');
        }
      });
    }
    else {
      self.before[i](self, self.target);
    }
  })(-1);  
};

RoutingStream.prototype.onError = function (err) {
  this.emit('error', err);
};

RoutingStream.prototype.login =
RoutingStream.prototype.logIn = function(user, options, done) {
  if (!this._passport) throw new Error('passport.initialize() middleware not in use');
  
  if (!done && typeof options === 'function') {
    done = options;
    options = {};
  }
  options = options || {};
  var property = this._passport.instance._userProperty || 'user';
  var session = (options.session === undefined) ? true : options.session;
  
  this[property] = user;
  if (session) {
    var self = this;
    this._passport.instance.serializeUser(user, function(err, obj) {
      if (err) { self[property] = null; return done(err); }
      self._passport.session.user = obj;
      done();
    });
  } else {
    done && done();
  }
};

/**
 * Terminate an existing login session.
 *
 * @api public
 */
RoutingStream.prototype.logout =
RoutingStream.prototype.logOut = function() {
  if (!this._passport) throw new Error('passport.initialize() middleware not in use');
  
  var property = this._passport.instance._userProperty || 'user';
  
  this[property] = null;
  delete this._passport.session.user;
};

/**
 * Test if request is authenticated.
 *
 * @return {Boolean}
 * @api public
 */
RoutingStream.prototype.isAuthenticated = function() {
  var property = 'user';
  if (this._passport && this._passport.instance._userProperty) {
    property = this._passport.instance._userProperty;
  }
  
  return (this[property]) ? true : false;
};

/**
 * Test if request is unauthenticated.
 *
 * @return {Boolean}
 * @api public
 */
RoutingStream.prototype.isUnauthenticated = function() {
  return !this.isAuthenticated();
};
